# Behavior

Behavior, as previously mentioned, is where the structural building blocks in combination with their adorned materials and objects *respond*. They respond to interaction, the environment, and ultimately time. Behavior enables a specific building block, group of building blocks, and/or adornments to change in time. These changes manifest in an infinite amount of ways.

The possible behavior(s), and their respective ease of application, is contextual. In the context of 2D with the web platform, behavior is applied via JavaScript code. In the context of 3D and Unity, behavior is applied via C# code. Each coding language, in conjunction with each platform’s authoring tools, provides ways to help you apply certain behavior. Naturally, Unity with C# provides ways (superior ways) to apply behavior in 3D space. 

Behavior(s) may be different depending on the context, but their fundamental purpose remains constant. Behavior brings life to a design. It does so in the form of interactivity, motion, and/or logic. For example, a design with behavior may manifest as a creative authoring environment, an entertaining animation, or a mission critical tool. The manifestations are endless and limited only by your imagination.

Let’s explore some specific applications of behavior by building off the previous structure and style examples.

 *^ TODO - (structural, styles, logical) ^*

We know behavior(s) may be applied to structure (a specific building block or group of building blocks). Additionally, we know behavior may be applied to style (adornments). The sheer presence of behavior however, due to its dynamic nature, results in an additional target. Time itself. Time in the form of delays and schedules are most common.

Now is a good time to explicitly identify example triggers that result in behavioral responses. The triggers are *input* and the response is *output*. Without these input triggers, a design remains static and lacks dynamism, it lacks life. There are three types of input triggers:

1. user interaction (ex. tap, click, hit, hover, etc.)

2. environment (ex. layout resizing, operating system, device sensor, etc.)

3. time (ex. delays, schedules, etc.)

New building blocks or groups of building blocks may be added to the structure dynamically. They can also be removed dynamically. Adornments are added or removed the same way. Behavioral changes to these structures and/or adornments are just as easily modifiable based on any of these three triggers. The takeaway is that there are three input triggers that result in output behavior. The result itself is up to you as the coder.

Ultimately, where traditional visual design is static, behavior makes a design dynamic. This power is addictive, useful, and extremely empowering. In the context of the web platform and Unity, instead of using solely what the JavaScript and C# code provides, you can *extend* their capabilities with your *own* code. You can invent entirely new and better ways to do almost anything. Super cool.
