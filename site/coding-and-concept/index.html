<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Coding and Concept</title>
  <meta name="description" content="...">
  <link href="https://fonts.googleapis.com/css?family=Lato:400,900" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="../assets/css/style.css">
</head>
<body>
  <header>
    <p>
      <a href="/preface">Ch0</a>
      <a href="/breaking-barriers">Ch1</a>
      <a href="/structure-style-and-behavior">Ch2</a>
      <a href="/coding-and-visual-design">Ch3</a>
      <a href="/coding-and-concept">Ch4</a>
      <a href="/coding-and-javascript">Ch5</a>
      <a href="/deconstructing-designs">Ch6</a>    </p>
  </header>
  <section>
    <h1 class='chapter-title'>Coding and Concept</h1>
    <h2 id="coding-and-concept">Coding and Concept</h2>
<p>So far we&#39;ve broken down some barriers around coding and computers in general. We&#39;ve learned about coding structure, style, and behavior too. Additionally, we&#39;ve introduced coding relative to visual design&#39;s elements, principles, and constructs. Though there is always more to learn, your confidence should be magnitudes higher than when we started. Additionally, a strong mental model should be forming. Let&#39;s strengthen it even more.</p>
<p>To do so, we will visit one more set of concepts before getting into JavaScript itself. Virtually all of these concepts are language agnostic. Hell yea.</p>
<p>In this section, we will visit the most important programming concepts that will help shape your future programming efforts. We will talk about the three main and distinct timeframes when code exists. These are <em>authoring time</em>, <em>compile time</em>, and <em>execution time</em>. This knowledge will help you understand the difference between when you are authoring code to when people will be able to use your interactive creations. Following this, we will visit the <em>frame rate</em> and <em>event loop</em> concepts in detail so we have a fine-tuned grasp of what actually happens during <em>execution time</em>.</p>
<p>Next we will explore the differences between <em>sync</em> (happens now) and <em>async</em> (happens later) behavior. This exploration will naturally tie into visiting <em>interfacing</em> and the <em>client-server model</em>. As a result, we will learn how code talks to other code while also learning the specific benefits of having multiple devices communicate and/or do dedicated and unique work.</p>
<p>Second to last, we will look at the <em>anatomy of a source code file</em> for HTML (<code>.html</code>), CSS (<code>.css</code>), and JavaScript (<code>.js</code>). This will allow us to reference real code against various concepts covered thus far. Lastly, we will cover the <em>work. right. better.</em> mantra to help you improve your code authoring over time. All coders live by this, myself included.</p>
<p>Upon completion of this section, your mental model will be primed for programming in JavaScript. Let&#39;s get going.</p>
<h2 id="authoring-compiling-and-executing">Authoring, Compiling, and Executing</h2>
<p>As mentioned previously there are three distinct timeframes when code exists. In order, these are:</p>
<ol>
<li>Authoring time</li>
<li>Compile time</li>
<li>Execution time</li>
</ol>
<p>These distinct timeframes are useful for understanding how the static code we author in a text file enables a dynamic and interactive creation to exist in real-time. We will also touch on why this transformation even needs to occur.</p>
<p><em>Authoring time</em> is pretty self-explanatory right? It is the time when we are authoring code. That&#39;s it. We have a text editor program of some kind open and we are typing or pasting into it. Simple as that. Some programs even exist, like Unity for example, that enable a more visual programming approach. This simply means that the program has some amount of UI interaction that enables you as the author to <em>generate</em> code in a non-text based way. Admittedly, this is often more fun than text-based programming... but there is a catch.</p>
<p>Inevitably, these visual tools are limiting as they do not allow you to pull off exactly what you want. This is why we&#39;re concentrating on authoring custom code in a text editor. We get <em>ultimate control</em> as to how something works because <em>we get to write the code</em>.</p>
<p>After we have authored the code, we need to &quot;run&quot; or &quot;execute&quot; it. Executing it helps us confirm that it actually does what we want in real-time. Before we can do this however, a step needs to be taken that transforms our static authored code into code that can be executed. Welcome to <em>compile time</em>.</p>
<p>Compile time is how we get from our authored <em>static</em> code to <em>dynamic</em> code that manifests as an interactive application or game. We won&#39;t go into the details of this step as it is complex. All you need to know is that this step exists so <em>we</em> can use words <em>we</em> understand instead of coding in binary, the only thing computers fundamentally understand. A prime example is how we use English words (and English abbreviations) within the programming language JavaScript.</p>
<p>In essence, some smart and nerdy authors wrote a <em>compiler program</em> that compiles and converts a high-level programming language like JavaScript (easier for us humans to use) to lower-level languages (easier for super-nerdy humans to use) to binary (easier for super-super-nerdy humans and computers to use).</p>
<p><img src="../assets/img/visual-todo-placeholder.jpg" alt="alt text" title="Author &gt; Compile &gt; Run"></p>
<p>The output of this compilation process results in code that the computer <em>executes</em> in real-time. This process often manifests as an interactive user interface in an application or an interactive environment in a game.</p>
<p>With Unity, the process is:</p>
<ol>
<li><em>Author</em> code in a text editor and/or with Unity&#39;s built-in UI that generates code</li>
<li>Click the &quot;Build&quot; button to <em>compile</em> the authored code into an executable package</li>
<li><em>Execute</em> this file&#39;s code on the target operating system in real-time<ul>
<li>Remember file extensions? ;)</li>
</ul>
</li>
</ol>
<p>With JavaScript in a web browser, the process is:</p>
<ol>
<li><em>Author</em> code in a text editor and/or a tool that helps generate code</li>
<li>View a web page that hosts your authored JavaScript code, the browser <em>compiles</em> it on the fly</li>
<li>This compiled code is then automatically <em>executed</em> in real-time </li>
</ol>
<p>To recap, we write in a high-level language using English words and abbreviations. This is author time. Then a compiler program converts the code we humans can understand into code the computer understands. This is compile time. Finally, if the conversion process has no errors, the result is an application or game that is interactive. This is execution time.</p>
<p>How is execution time actually interactive though? One or more users could take any number of actions within our application or game at any given moment. We can&#39;t possibly handle all these potential scenarios in our code can we? Thankfully the answer is yes we can. We just need to understand the <em>frame rate</em> and the <em>event loop</em>.</p>
<h2 id="frame-rate">Frame Rate</h2>
<p>We know computers are dumb and fast. Some computers are faster than others however. How do we ensure the code we author will execute well on a given computer? To do so, we need to author our code with a target <em>frame rate</em> in mind.</p>
<p>A frame rate is simply the amount of frames that are shown in a second. A frame is a single rendered image. Frames shown back to back over time create the illusion of motion. Common target frame rates are:</p>
<ul>
<li>30fps (video)</li>
<li>60fps (apps/games)</li>
<li>90fps (AR/VR)</li>
</ul>
<p>As you likely guessed, a high frame rate results in the illusion of smooth motion. A slow frame rate results in an illusion of less smooth motion. The human eye typically needs 24fps or more for a smooth perception of motion to be recognized. Within an interactive medium like applications or games, 60fps is a common target.</p>
<p>It is worth noting that if your application or game does not change often and/or lacks animation, you will likely be able to get away with 10fps or 5fps. The more motion and animation you have however, the more likely you&#39;ll want to target 60fps. Generally, the richer and more fluid the experience, the greater the frame rate.</p>
<p>An application or game that targets 60fps must render a new image every 16.6 milliseconds. Damn, that&#39;s fast.</p>
<p><em>^ 1 second = 1000 milliseconds so 1000ms/60fps = 16.6ms per frame ^</em></p>
<p>Milliseconds might be intimidating at first, but you&#39;ll get used to them quickly. In fact, you likely already have an intuitive understanding of milliseconds. Do you ever feel an  animation within an application or game is too slow or too fast? The milliseconds chosen as the animation time is the culprit.</p>
<p>You usually don&#39;t have to worry about the 16.6ms window however. I present it here simply for you to keep it in the back of your mind.</p>
<p>In the future, if your application&#39;s animation and motion seems to have hiccups or it looks janky, then you likely have a problem or two. Typically this means your code, or a 3rd-party&#39;s code, is: </p>
<ol>
<li>doing too much work each frame</li>
<li>doing work inefficiently</li>
</ol>
<p>We&#39;ll revisit these two problems later, but just be aware of them.</p>
<p>So a frame rate is vital for percieved motion, that&#39;s great. But how do we actually allow interactivity to be reflected in this motion? <em>Event loop</em> time.</p>
<h2 id="event-loop">Event Loop</h2>
<p>An interactive application or game is simply the manifestation of a target sixty rendered images, shown in sequence, per second. The only reason this frame rate is important is so the user&#39;s experience is perceptually fluid and responsive. If fluidity and responsiveness were not a perceptual goal, our application or game could leverage 10fps, 5fps, or an even lower target frame rate. More often than not however we desire the interactive content we create to be extremely fluid and responsive. 60fps? Yes please.</p>
<p>A non-interactive animation hitting 60fps undoubtedly looks smooth, but it is just that, <em>non-interactive</em>. How do we account for this desired interactivity?</p>
<p>Thankfully, the program responsible for <em>executing</em> our compiled code helps us out. This program is called the <em>engine</em>. Additionally, the engine gets help from its parent program, the <em>runtime</em>. Together, the runtime and engine provide an interactive system that executes code in real-time. If we were to code the relationship in an HTML-like code, it would look like this:</p>
<pre><code>&lt;runtime&gt;
    &lt;engine&gt;&lt;/engine&gt;
&lt;/runtime&gt;
</code></pre><p>For us to take advantage of the runtime and engine, we just need to get an idea of how they work together. This allows us to author code that reacts interactively as the engine executes it in real-time.</p>
<p>The JavaScript runtime in a web browser has four core parts and the engine has two:</p>
<ol>
<li>engine<ul>
<li><em>heap</em></li>
<li><em>stack</em></li>
</ul>
</li>
<li><em>runtime APIs</em></li>
<li><em>event queue</em></li>
<li><em>event loop</em></li>
</ol>
<p>We can update our HTML-like example from before:</p>
<pre><code>&lt;runtime&gt;
    &lt;engine&gt;
        &lt;heap&gt;&lt;/heap&gt;
        &lt;stack&gt;&lt;/stack&gt;
    &lt;/engine&gt;
    &lt;apis&gt;&lt;/apis&gt;
    &lt;queue&gt;&lt;/queue&gt;
    &lt;loop&gt;&lt;/loop&gt;
&lt;/runtime&gt;
</code></pre><p>So what do each of these runtime parts do anyway? Here is a succint breakdown where the use of <em>work</em> implies some amount of code reading and/or executing:</p>
<ol>
<li>engine - does work<ul>
<li><em>heap</em> - memory for work</li>
<li><em>stack</em> - organizes the engine&#39;s work</li>
</ul>
</li>
<li><em>runtime APIs</em> - does special work the engine cannot</li>
<li><em>event queue</em> - organizes the results of special work as packages of engine work</li>
<li><em>event loop</em> - gives the engine queued packages of work</li>
</ol>
<p>Here is a 3D representation of the relationship between the runtime and engine parts:</p>
<p><img src="../assets/img/visual-todo-placeholder.jpg" alt="alt text" title="The Event Loop Machine"></p>
<p><em>^ The Event Loop Machine ^</em></p>
<p>During compile time, just before execution time, the engine quickly does three things with our code:</p>
<ol>
<li>reads</li>
<li>reorganizes</li>
<li>optimizes</li>
</ol>
<p>These steps enable the engine to run fast and efficiently during execution time. Execution time is when the runtime and engine work together to achieve two goals:</p>
<ol>
<li>clear the stack</li>
<li>clear the event queue</li>
</ol>
<p>Once these two goals are met, the engine can relax. It relaxes until new work is added to its stack. How does it get new work though? Do you remember the input triggers we covered in the <em>Behavior</em> section? Bingo. As a reminder, these input triggers, often called <em>events</em>, are:</p>
<ol>
<li>user interaction (tap, click, hover, gesture, voice, etc.)</li>
<li>environment (layout resizing, operating system, device sensors, etc.)</li>
<li>time (delays, schedules, etc.)</li>
</ol>
<p>When an event occurs, the runtime APIs manage the special work required and then update the event queue when finished. Since the event loop has been cycling while the engine was relaxing, it now notices the updated event queue. Consequently, it takes one item from the queue and gives it to the engine. The engine then puts it on the stack. You guessed it, new work for the engine. This process cycles.</p>
<p>Though all of the runtime&#39;s parts are vital, the event loop most ensures our interactive creations come to life. Thanks event loop.</p>
<h2 id="sync-and-async">Sync and Async</h2>
<p>Though we didn&#39;t explicitly state it, the nature of how the event loop works gives rise to the notion of <em>sync</em> and <em>async</em> work. Synchronous and asynchronous are the full terms, but we will use the shortcuts sync and async instead.</p>
<p>Sync work is referred to as <em>blocking</em> where async work is <em>non-blocking</em>. Using your new knowledge of the event loop, how would you categorize the engine&#39;s stack work? How about the runtime APIs work? I&#39;ll give you a clue, they are different. Take a moment before continuing.</p>
<p>Answer time:</p>
<table>
  <tr>
    <td>sync</td>
    <td>blocking</td>
    <td>stack work</td>
  </tr>
  <tr>
    <td>async</td>
    <td>non-blocking</td>
    <td>runtime APIs work</td>
  </tr>
</table>

<p>The 3D visualization from the <em>Event Loop</em> section should be popping into your head. The event loop cannot cycle when work is on the stack. The loop is blocked. The event queue does not prevent the event loop from cycling. The loop is not blocked.</p>
<p><img src="../assets/img/visual-todo-placeholder.jpg" alt="alt text" title="The Event Loop Machine"></p>
<p><em>^ The Event Loop Machine ^</em></p>
<p>Let&#39;s look at code examples of both work types to see this in action. We haven&#39;t specifically covered JavaScript outside the <em>Elements and Elements</em> section yet, but I am confident you&#39;ll get the gist.</p>
<p>Sync work:</p>
<pre><code>function makeBackgroundBlack() {
  document.body.style.backgroundColor = &#39;#000000&#39;;
}

makeBackgroundBlack();
</code></pre><p>There are likely some details you don&#39;t understand, but that is to be expected. Let&#39;s look at the same code with some added explanations. Take note that the words following the <code>//</code> are plain English, not code. These plain English <em>comments</em> are useful for us humans when we read and share our code for others to read. Comments are for humans not computers. The engine ignores them.</p>
<pre><code>// 1. We declare a function statement (stack work) for the engine
// 2. We name the function whatever we want, &#39;makeBackgroundBlack&#39; in this case
// 3. The engine doesn&#39;t do the work yet (code statement between the &#39;{&#39; and &#39;}&#39;)
function makeBackgroundBlack() {

  // We set the document&#39;s background color to black (remember the Coding Color section?)
  document.body.style.backgroundColor = &#39;#000000&#39;;
}

// 1. We tell the engine to do work, the code sequence `();` is the trigger
// 2. Since we named the function, the engine knows the exact work to put on its stack
makeBackgroundBlack();
</code></pre><p>Without comments, there are naturally a lot less lines for us humans to read. As far as the engine is concerned however, these are the same program. As you gain more experience you will understand when and when not to use comments. When in doubt use them to help other coders, including your future self, understand your original intention.</p>
<p>Admittedly, the code above does not do a whole lot. The work inside of the <code>makeBackgroundBlack</code> function will happen really fast too. The event loop will technically be blocked for less than 1ms, but from a user&#39;s perspective the work will happen instantly and then the event loop will become unblocked. If the function instead counted to a million before changing the background color, then the user would percieve the program as slower (and rightly so).</p>
<p>The takeaway here is that you should try to do small and efficient work in your functions. As you author code over time, you will develop an intuitive understanding of what that really means. For now, put this idea in the back of your mind. Remember, the faster the stack and event queue are cleared, the greater the chance you will hit your target frame rate. 60fps? Yes please.</p>
<p>Let&#39;s now look at an async example. We will make it similar to the sync example for comparison. In fact, we will make the program identical except for a single statement and its comments.</p>
<p>Async work:</p>
<pre><code>function makeBackgroundBlack() {
  document.body.style.backgroundColor = &#39;#000000&#39;;
}

// 1. We tell the engine to do work, the code sequence `(makeBackgroundBlack, 1000);` is the trigger
// 2. &#39;setTimeout&#39; is a named built-in function that the &#39;runtime APIs&#39; provide, thank you runtime
// 3. The &#39;setTimeout&#39; function expects two argument values
setTimeout(makeBackgroundBlack, 1000);
</code></pre><p>Before reading on, try to guess what <code>setTimeout</code> does. How do you think it uses the argument values?</p>
<p>This async program is identical to the sync program except for one code statement. If we look up how the <code>setTimeout</code> function uses its arguments to do work, we can learn what work it does. I want to stress again that professional coders, just like beginners, use references to learn and remind themselves what certain functions do. Even the best cannot remember everything.</p>
<p>I will just tell you what arguments, in order, <code>setTimeout</code> expects:</p>
<ol>
<li>a function</li>
<li>a time in milliseconds</li>
</ol>
<p>The work <code>setTimout</code> actually does, in English, is:</p>
<ol>
<li>create a timer</li>
<li>run the timer for the time in milliseconds provided</li>
<li>wait for the timer to complete</li>
<li>upon completion, update the event queue with the function provided</li>
</ol>
<p>What is cool about many functions, <code>setTimeout</code> included, is that they can be designed with a small amount of flexibility built-in. As you may have guessed, as long as we give <code>setTimeout</code> valid arguments, it will always do the work we want (via the function provided) after a delay (via the time provided). Pretty damn cool. You can design your own functions with flexibility as well.</p>
<p>As a quick example, let&#39;s design a new function named <code>changeBackgroundColor</code>.</p>
<pre><code>function changeBackgroundColor(newColor) {
  document.body.style.backgroundColor = newColor;
}
</code></pre><p>Here are a few examples of how we could use it:</p>
<pre><code>changeBackgroundColor(&#39;#FF0000&#39;);
</code></pre><p>or</p>
<pre><code>changeBackgroundColor(&#39;Green&#39;);
</code></pre><p>or</p>
<pre><code>changeBackgroundColor(&#39;Blue&#39;);
</code></pre><p>You get the idea.</p>
<p>We explored some JavaScript a little bit in this section, but the main takeaway is the difference between sync and async. If you understand how to keep your stack work small and fast, you&#39;ll be running 60fps with no problem.</p>
<p>As you learn more about runtime APIs you will discover that the runtime will do a lot of really cool non-blocking work for you. If you haven&#39;t already noticed, the runtime APIs provide a simple <em>interface</em> for you as a code author to work with. Let&#39;s dig deeper into what that means.</p>
<h2 id="interfacing">Interfacing</h2>
<p>It wasn&#39;t important until now to tell you what the aforementioned <em>API</em> of runtime APIs stands for. Now is the time. Welcome to <em>Application Programming Interface</em>. Yea, that is a mouthful. Coders instead just say API (each letter pronounced individually).</p>
<p>An API is just an interface. The doorknob of a door is an interface. The steering wheel of a vehicle is an interface. The keys of a virtual keyboard are too. Interfaces provide a way to interact. The doorknob and steering wheel are physical interfaces designed for humans. A virtual keyboard is a digital interface also designed for humans. An API is a programming interface designed for code. An API allows code to interact with other code, this is the takeaway.</p>
<p>As a code author, you get ease-of-use while the underlying complexity is the code designer&#39;s responsibility. Think about it. As a driver of a vehicle, you do not need to know all the details of how the engine works to use it. The designers take that responsibility. Similarly with code, you just use the API provided to gain benefit. This is a pretty solid trade.</p>
<p>In the last section we saw one API, the built-in <code>setTimeout</code> function, in action. We wrote our code to interact with that API by giving it two argument values. Behind the scenes, the runtime wired up and provided the functionality we expected. Both you and I don&#39;t really care how the work is done as long as it gets done. This is the trade-off an API provides, a simpler way to do work. APIs rock!</p>
<p>Earlier in the <em>Constructs and Components</em> section we covered built-in, 3rd party, and custom components. Naturally, they each provide various APIs. As previously mentioned, we can create useful code for others to use too. Another author using our code APIs doesn&#39;t have to care about how the work actually gets done. They get the same trade-off as us, a simpler way to do work.</p>
<p>As you gain coding and programming experience, you&#39;ll memorize certain built-in and 3rd party APIs. This translates to improving your authoring speed. Don&#39;t worry about being slow when you start out, you&#39;ll get better in time.</p>
<p>This might sound weird at first, but some APIs exist on a different computer than the one your program runs on. Whoa. Have you ever wondered how a particular app or game can provide new content without actually updating the app? Welcome to the <em>client-server model</em>.</p>
<h2 id="client-and-server">Client and Server</h2>
<p>Clients and servers are computers that communicate over a network. The internet is one such network that facilitates this communication. Some of these computers are clients and some are servers. Sometimes a computer is both a client and a server. The distinction is simple. A client asks for data and the server provides it. The network between them is the communication channel.</p>
<p>The details of how the internet facilitates this communication is elegant and impressive, but not a focus of this book. I highly recommend <em>Introduction to Networking</em> by Charles Severance if you want to dig deeper, but it is not required reading to move forward. Just know that the internet enables a client computer and a server computer to talk.</p>
<p>Let&#39;s look at two example programs that utilize the internet to help solidify your understanding. One program will be a web browser and the other an internet-connected mobile game. Let&#39;s just say that each example is running on a smartphone. Both the browser and the game are on the client, the smartphone. Each program leverages distinct APIs to request information from distinct and remote computers, the servers. Pretty simple relationship really.</p>
<p><img src="../assets/img/visual-todo-placeholder.jpg" alt="alt text" title="Client and Server"></p>
<p><em>^ client and server graphic ^</em></p>
<p>You already know that a web browser may be used to access a particular website or web app. While the site or web app is running, its code can make <em>additional requests</em> to the server in an effort to get additional data. For example, when a sport statistics app is starting up, or another input trigger occurs, the app could use an API to get the most up-to-date scores and stats. An updated version of the app is not required. Instead, an API interaction provides updated data. This is super useful.</p>
<p>An internet-connected game works exactly the same way. When it starts up, or another input trigger occurs, it could make an API request to get current world-wide player rankings for the game. Additionally, if the designers and code authors designed the game in such a way, they could make different API requests for new worlds, levels, characters, etc. No update required. Pretty damn cool.</p>
<p>A server, if you didn&#39;t guess already, is also responsible for providing a client web browser the <em>initial</em> HTML, CSS, and JavaScript for a website or web app. If too many people try to access the same data at the same time however, the server can crash. It is worth noting that each client is actually getting a copy of the data to reconstruct in its browser. Typically a crash occurs because the server software can&#39;t properly provide the various clients the copies fast enough. I mention this simply because many people don&#39;t grasp the fact that the client reconstructs what the server provides.</p>
<p>Having talked about HTML, CSS, and JavaScript at solely a high level thus far, now is a great time to venture deeper. We&#39;ll do so next by exploring the anatomy of the three file types <code>.html</code>, <code>.css</code>, and <code>.js</code>.</p>
<h2 id="anatomy-of-html-css-and-javascript">Anatomy of HTML, CSS, and JavaScript</h2>
<p>This section will be the first where we really start digging into the existing languages of HTML, CSS, and JavaScript. We have covered quite a bit in an effort to get to this point. Specifically, we learned about the powerful concepts of binary and states in addition to encoding and decoding in the <em>Breaking Barriers</em> chapter. We learned in <em>Structure, Style, and Behavior</em> how each concept plays a valuable and distinct role in an interactive creation. In <em>Coding and Visual Design</em> we mapped familiar design-specific concepts to coding concepts to help establish a knowledge bridge. More recently, we explored programming-specific concepts to help shape your understanding of how code lives and communicates in real-time.</p>
<p>We know code is a system for converting meaning between forms and HTML, CSS, and JavaScript are just specific forms. HTML is a markup language used to define structure. CSS is a style language used to define style. JavaScript is a scripting language used to define behavior. The web browser knows how to decode HTML into divisions of content and render them. It also knows how to decode CSS property-value pairs to adorn the HTML elements with style and functionality. Lastly, we know a browser&#39;s runtime and engine understand how to decode and execute JavaScript which enables an interactive creation to exist.</p>
<p>We will now start to dig into HTML, CSS, and JavaScript since we have a greater understanding of how the various concepts we have covered play-off each other. Your mental model should be primed.</p>
<p>Let&#39;s squash a myth real quick. Designers and other non-coders new to coding think they need to learn an entire new language, and in the context of the web, <em>three</em> new languages. This is not true. What needs to be learned is the:</p>
<ol>
<li>Distinction between structure, style, and behavior</li>
<li>Anatomical implementation of structure, style, and behavior</li>
<li>Common subset of code words for each implementation (80/20 rule)</li>
</ol>
<p>For 2D and the web, that means we need to know the difference between HTML structure, CSS styling, and JavaScript behavior. We have this distinction covered. Let&#39;s dig into number two and three. Learning these two facets for each language won&#39;t be easy, but it can be simple. Regardless, there is no substitue for practice.</p>
<h3 id="html">HTML</h3>
<p>In keeping with the structure, style, and behavior order, let&#39;s look at the anatomy of each starting with HTML. We will title our file <code>index.html</code> to align with a best practice naming convention.</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Coding for Designers&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;Content goes here.&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>This is the most structurally simple, complete, and valid HTML a browser uses. Let&#39;s walk through each tag using <em>comments</em> to clarify each tag&#39;s purpose. We saw earlier that JavaScript uses the <code>//</code> character sequence for comments. HTML uses the <code>&lt;!----&gt;</code> sequence where the actual comment rests in the middle of the dashes. Just take note that each language may have a uniqe approach to comments, but the purpose is the same. Yes, it would be ideal if all languages used the same character sequence for denoting comments. It&#39;s not a perfect world.</p>
<pre><code>&lt;!-- Tell the browser the document type - we only care about html --&gt;
&lt;!DOCTYPE html&gt;

&lt;!-- Tell the browser where we&#39;ve defined our html - additional data exists outside it --&gt;
&lt;html&gt;

  &lt;!-- Define the page metadata - useful data for the browser, other programs, and search engines --&gt;
  &lt;head&gt;

    &lt;!-- Define the character encoding - inform the browser how to reliably decode this document --&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;

    &lt;!-- Define the page title - useful for the browser, other programs, and search engines --&gt;
    &lt;title&gt;Coding for Designers&lt;/title&gt;

  &lt;!-- Define the page metadata end --&gt;
  &lt;/head&gt;

  &lt;!-- Define the page content - what gets rendered for viewing and user interaction --&gt;
  &lt;body&gt;Content goes here.&lt;/body&gt;

&lt;!-- Define the html end --&gt;
&lt;/html&gt;
</code></pre><p>There are many types of element tags that can be added in both the <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> element tags. As mentioned earlier, we will not go over them here as you, just like other coders, can use other resources to look up what tags are available. We will reveal the most common ones for the <code>&lt;body&gt;</code> however to fulfill the <em>common subset</em> bullet above. Instead of comments I will use English inline with the tags to show how the elements wrap content. Content is visible to the user where the tags that wrap the content are not. The tags simply tell the browser your structure, the building block parent-child relationships. The spacing <em>between elements</em> is not important as the browser understands the structure regardless. Spacing <em>between content</em> is what matters.</p>
<p>Spacing, tabs, and new lines do typically exist between elements however. This is solely to improve human readability. Imagine if the below HTML elements were all on a single line. The browser wouldn&#39;t care as the defined structure would remain the same, but we would have a much tougher time reading and easily seeing the parent-child relationships.</p>
<pre><code>&lt;body&gt;
  &lt;div&gt;
    &lt;h1&gt;This is the Primary Title of the Page&lt;/h1&gt;
    &lt;p&gt;This is a paragraph. It is followed by an image and a button.&lt;/p&gt;
    &lt;img&gt;&lt;/img&gt;
    &lt;button&gt;Toggle Image Opacity&lt;/button&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;h2&gt;This is a Secondary Title&lt;/h2&gt;
    &lt;p&gt;This is another paragraph. It has a &lt;a&gt;hyperlink&lt;/a&gt;.&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre><p>A <code>&lt;div&gt;</code> tag simpy denotes a division of content where the layout (position and dimension) of each division is dependent on style. This will likely become your most used element tag. The <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;button&gt;</code>, and <code>&lt;h2&gt;</code> tags are self-describing, but the <code>&lt;img&gt;</code> and <code>&lt;a&gt;</code> tags are not. This is because they are each lacking <em>attributes</em>. We&#39;ll use the shortcut <em>attrs</em> moving forward. All elements can leverage attrs, but these latter two elements <em>require</em> them to function as designed.</p>
<p>Think of attrs as APIs. Attrs enable the coder to achieve functionality based on a shared understanding of designed use. They are also where we start to transition toward CSS via the <code>class</code> attr. First we will update the <code>&lt;img&gt;</code> and <code>&lt;a&gt;</code> tags with each of their most useful attrs.</p>
<p>So <code>&lt;img&gt;&lt;/img&gt;</code> becomes <code>&lt;img src=&#39;assets/img/cover-coding-for-designers.jpg&#39;&gt;&lt;/img&gt;</code> where the <code>src</code> attr is set with <code>=</code> to the value <code>assets/img/cover-coding-for-designers.jpg</code> between quotes. Quotes define the start and end of the attr value. The browser knows how the image tag is designed to work so its runtime APIs automatically download the image provided by the <code>src</code> attr, which is the path to the asset. Upon completion of the download, the tag embodies the downloaded image. This same functionality can be achieved using JavaScript only, but we&#39;d have to write more code. Remember, APIs provide a tradeoff and a simpler way to do work.</p>
<p>Additionally, <code>&lt;a&gt;hyperlink&lt;/a&gt;</code> becomes <code>&lt;a href=&#39;http://www.codingfordesignersbook.com&#39;&gt;hyperlink&lt;/a&gt;</code> where the <code>href</code> attr is set with <code>=</code> to the value <code>http://www.codingfordesignersbook.com</code> between quotes. The browser knows that the anchor tag, when hit, should change the web page to the value provided. This same functionality can be achieved using JavaScript only, but we&#39;d have to write more code. Again, the goal is a simpler way to do work.</p>
<p>The takeaway is that the browser provides useful runtime API hooks via element attrs. Now that we&#39;ve covered the basic implementation of HTML structure, let&#39;s dig into style. Welcome to the <code>class</code> attr.</p>
<h3 id="css">CSS</h3>
<p>The <code>class</code> attr gives you the creative power to style content. We will start by giving each <code>&lt;div&gt;</code> the same style. So <code>&lt;div&gt;</code> becomes <code>&lt;div class=&#39;dark-background&#39;&gt;</code> where the <code>class</code> attr is set with <code>=</code> to the value <code>dark-background</code> between quotes. The <code>dark-background</code> name could be virtually anything we want, but there are rules for valid names. Make it easier on yourself and stick with:</p>
<ul>
<li>Lowercase English alphabet characters</li>
<li>Use <code>-</code> instead of spaces</li>
</ul>
<p>Now that we have set a <code>dark-background</code> value for the <code>class</code> attr, how do we actually define the style for the browser to render it? Remember when I mentioned that other tags can be added to the <code>&lt;head&gt;</code>? Welcome to the <code>&lt;link&gt;</code> tag. It allows us to link another file to our web page. Perfect. Our updated <code>&lt;head&gt;</code> is below and it now has a <code>&lt;link&gt;</code> tag. The attrs of it tell the browser to download and use a CSS file where our defined <code>dark-background</code> style resides.</p>
<pre><code>&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;

  &lt;!-- &#39;rel&#39; defines the href relationship type - &#39;href&#39; defines the hyperlink reference --&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/style.css&quot;&gt;

  &lt;title&gt;Coding for Designers&lt;/title&gt;
&lt;/head&gt;
</code></pre><p>The folder structure on the server computer that is providing these files to client computers is below. Take note that a lacking file extension means the item is a folder. The <em>relative</em> paths of the <code>&lt;link&gt;</code>&#39;s <code>href</code> attr value and the <code>&lt;img&gt;</code>&#39;s <code>src</code> attr value rely on the structure below. These relative paths, relative to the <code>index.html</code> that is, tell the browser exactly where to find the file to use.</p>
<pre><code>index.html
assets
  css
    style.css
  img
    cover-coding-for-designers.jpg
</code></pre><p>Now is the time to look at the anatomy of a <code>.css</code> file which, for our purpose, consists of one class definition. Typically the file would have more than one, but currently we only need one. Take note that CSS uses <em>comments</em> via <code>/**/</code> where the comment itself resides in the middle. Our <code>style.css</code> file is simply:</p>
<pre><code>.dark-background {

  /* This is a CSS comment - the below property-value pair sets an element&#39;s background color to black */
  background-color: #000000;

}
</code></pre><p>Each class definition is denoted by a preceding <code>.</code> so our <code>dark-background</code> class becomes <code>.dark-background</code> within our <code>.css</code> file. Then, similar to the JavaScript scope concept we visited earlier, the property-value pairs are defined between the <code>{</code> and <code>}</code> characters. The <code>{</code> and <code>}</code> define the scope, the space and enclosure, where one or more property-value pairs are associated with a particular class.</p>
<p>Each property-value pair consists of a property name that uses the same rules for class naming suggested above, followed by a <code>:</code> and then an actual value. For ease of learning, I wish the <code>:</code> was <code>=</code> instead, but I digress. With a class and its valid property-value pair(s) defined, any element that has a <code>class</code> by the same name will get the styles applied. Pretty damn cool and very reusable.</p>
<p>If it isn&#39;t already obvious, each browser sets default styles for elements to provide some baseline style. More often than not, you&#39;ll want to set your own styles to override the defaults. This is why we created <code>style.css</code>.</p>
<p>Since browsers typically default the color of text to black, our applied <code>dark-background</code> class makes our text blend with the dark background. We want to see the text too so we can fix this by updating our class definition to use another common property named <code>color</code>. Again, we won&#39;t go over all the valid properties that are possible as you, like other coders and designers, can reference resources. The takeaway is the relationship of property-value pairs within class definitions. Here is one approach to update our <code>style.css</code> file:</p>
<pre><code>.dark-background {
  background-color: #000000;
  color: #ffffff;  
}
</code></pre><p>Another approach could be:</p>
<pre><code>.dark-background {
  background-color: #000000;
}

.light-text {
  color: #ffffff;
}
</code></pre><p>Our <code>&lt;div&gt;</code>s would need to be updated for the second solution. Take note that spaces are used between class names to enable more than one class style to be applied to a single element. This is a very powerful aspect of CSS, one which you will grasp more intuitively in time. Updated HTML using the second solution is below:</p>
<pre><code>&lt;div class=&#39;dark-background light-text&#39;&gt;
</code></pre><p>With either solution, both our <code>&lt;div&gt;</code>s will have dark backgrounds and the text within them will be light. You might wonder how the text of the child elements can be light without explicitly setting styles on them. This is where the <em>cascading</em> part of cascading style sheets comes in. Think of cascading as style inheritence. Long story short, a majority of property-value styles can be inherited regardless of nested element depth. Cascading is extremely powerful and you will learn its nuances in time.</p>
<p>As a creation evolves, feel free to change the names of classes if it makes sense to. A class name may make less sense as new property-value pairs are added or removed. Over time you will leverage established naming practices and/or develop your own to gain an intuitive feel of when to update a name. Additionally, you&#39;ll develop a sense of how best to group certain property-value pairs for reuse by different elements. Just know that it is extremely common to change names as a creation evolves.</p>
<h3 id="javascript">JavaScript</h3>
<p>Thus far we&#39;ve covered the anatomy of HTML and CSS, so now it is time for JavaScript. In a way we already looked at the anatomy of JavaScript in the <em>Elements and Elements</em> section. That breakdown was a bit more granular though and we&#39;ll revisit the specifics in the next chapter <em>Coding and JavaScript</em>. For now we will look at the high level anatomy of a JavaScript program. We will focus on shape, space, and form or more precisely function, scope, and object.</p>
<p>As you already know, a function is like a shape because it encloses scope just as a shape encloses space. An enclosure helps prevent clashing of what exists between different scopes or spaces. No clashing please. Objects, like forms, are a higher level enclosure. More often than not, they each embody one or more functions or shapes respectively. JavaScript, like the majority of programming languages, has specific types of objects. JavaScript is fairly unique however in that a function is <em>also</em> an object.</p>
<p>Long story short, a JavaScript program is essentially a nested tree of functions. As a byproduct of functions each enclosing a scope, a JavaScript program can also be thought of as a nested tree of scopes. So when the JavaScript engine evaluates an expression that has a reference, it works like this in an effort to get the bound value:</p>
<ol>
<li>Look in the target scope for the reference</li>
<li>If not found, look in that scope&#39;s parent scope</li>
<li>Repeat until the reference is found or the root parent scope is hit</li>
</ol>
<p>When the reference is found in one of the scopes, the engine uses the value that is bound to the reference and continues to do work. This is what we want. If the root scope is hit and the value does not exist, then we have a problem. We will go into detail later regarding this scenario, so just be aware of it.</p>
<p>Now that we know the anatomy of a JavaScript program is simply a nested tree of scopes, let&#39;s add a simple example based on this section&#39;s HTML and CSS examples. As you might imagine, HTML has a tag that allows us to add JavaScript just as easily as we added CSS. Welcome to the <code>&lt;script&gt;</code> tag. You can add a <code>&lt;script&gt;</code> tag to the <code>&lt;head&gt;</code> or the <code>&lt;body&gt;</code>, but the latter is best practice for non-blocking reasons. Specifically, <code>&lt;script&gt;</code> tags should reside just before the closing body, the <code>&lt;/body&gt;</code>. Here is an updated excerpt from our <code>index.html</code> file.</p>
<pre><code>    &lt;!-- The previous HTML code from our index.html file is excluded for brevity --&gt;
    &lt;script src=&#39;assets/js/main.js&#39;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre><p>Naturally, the server folder structure needs the path to our <code>main.js</code> so our updated structure becomes:</p>
<pre><code>index.html
assets
  css
    style.css
  img
    cover-coding-for-designers.jpg
  js
    main.js
</code></pre><p>The browser understands the script tag and its <code>src</code> attr and then, you guessed it, the browser automatically downloads it. When completely downloaded, the runtime and engine take over with compilation and execution of its contents. Before we look at the contents of our <code>main.js</code> file, let&#39;s update our <code>&lt;img&gt;</code> and <code>&lt;button&gt;</code> HTML to more easily use each with JavaScript.</p>
<p>The updated <code>&lt;img&gt;</code> becomes:</p>
<pre><code>&lt;img id=&#39;image-to-toggle&#39; src=&#39;assets/img/cover-coding-for-designers.jpg&#39;&gt;&lt;/img&gt;
</code></pre><p>The updated <code>&lt;button&gt;</code> becomes:</p>
<pre><code>&lt;button onclick=&#39;toggleImageOpacity()&#39;&gt;Toggle Image Opacity&lt;/button&gt;
</code></pre><p>The <code>id</code> attr is how we identify an element in our HTML as unique to our document. An id means we intend there to be only one element with a specific name. A unique id enables us to gain a reference to the element&#39;s corresponding object for use in JavaScript. With this JavaScript reference we can use its API to do all sorts of cool things.</p>
<p>The result of clicking the button above during execution time results in the function named <code>toggleImageOpacity</code> to be called via <code>()</code>. This results in the function&#39;s contents being executed by the engine. Behind the scenes, the runtime APIs transform the hardware input (mouse, trackpad, stylus, touch, etc.) to event queue work. The event loop then picks up the resulting package and it gets placed on the stack. This all happens in milliseconds or even microseconds when the event loop is not blocked. Lastly, the engine actually executes the function contents. Now is a great time to look at those contents that reside in our <code>main.js</code> file.</p>
<pre><code>function toggleImageOpacity() {

  // Reference work
  var imageToToggle = document.getElementById(&#39;image-to-toggle&#39;);
  var currentOpacity = window.getComputedStyle(imageToToggle).opacity;

  // Core work
  if(currentOpacity == 1) {
    imageToToggle.style.opacity = .5;
  } else {
    imageToToggle.style.opacity = 1;
  }

}
</code></pre><p>Do not worry if you cannot understand everything in the above function as we&#39;ll cover it in great detail in the next section. You should however be able to grasp what is happening each time the <code>toggleImageOpacity</code> function executes. The image&#39;s opacity style is simply toggled between <code>.5</code> (50%) and <code>1</code> (100%). Take note that the function is structured in two parts:</p>
<ol>
<li>Reference work</li>
<li>Core work</li>
</ol>
<p>A function is not always structed this way by a coder, but JavaScript compilation essentially enforces it. We don&#39;t go into the details of compilation as previously mentioned, but look into <em>JavaScript hoisting</em> if you want to dig deeper. Just save yourself some pain and declare your identifiers (<code>var</code>s first and <code>function</code>s second) at the top of their parent function prior to use.</p>
<p>Admittedly, this program is tiny as it is comprised of only one small function. Take note however that programs of all sizes leverage this structure since they are just functions nested in functions. We will consider larger programs later in the <em>Coding and JavaScript</em> chapter to see this in action.</p>
<p>Before advancing to the next chapter though, we&#39;ll dive really deep into the <code>toggleImageOpacity</code> function. The function <em>works</em>, but we can <em>improve</em> it.</p>
<h2 id="work-right-better-">Work. Right. Better.</h2>
<p>In programming there is the axiom &quot;make it right before you make it faster&quot;. This exact quote is found in <em>The Elements of Programming Style</em> by Brian W. Kernighan and P.J. Plauger and it is heavily respected by the programming community. Put another way, when authoring code you should make it:</p>
<ol>
<li>Work</li>
<li>Right</li>
<li>Better</li>
</ol>
<p>In this section we will explore the notion of <em>right</em> and <em>better</em> in reference to the working <code>toggleImageOpacity</code> function that we recently looked at. This effort will introduce reusable code improvement tactics and the thought process behind them. The three step process will become second nature in time.</p>
<p>First and foremost you need the code to <em>work</em>. No shit. Making it <em>right</em> is less obvious though. Typically the goal is to achieve the same functionality with less and/or more efficient code. Making it <em>better</em> is much more subjective.</p>
<p>Is the code better for beginner and junior coders? Is it better for advanced and senior coders? Is it better for the computer? Sometimes the solution is ideal for all, but this is not always the case. For example an advantageous language feature may be common sense to an advanced coder, but confusing to a beginner coder. The code is better for one group and less so for the other. Similarly, when program performance is a bottleneck, better may mean sacrificing human readability. This should be avoided, but it is sometimes necessary. This latter example translates to an advantage during compilation time and/or execution time, but a disadvantage to authoring time.</p>
<p>Below is the <code>toggleImageOpacity</code> function from the previous section with added comments. Each comment is numbered for reference as we will soon be investigating the code line-by-line. After we understand each line of code, we will entertain improvement ideas.</p>
<pre><code>// 1. function declaration using toggleImageOpacity identifier
function toggleImageOpacity() {

  // 2. variable declaration and assignment using imageToToggle identifier
  var imageToToggle = document.getElementById(&#39;image-to-toggle&#39;);

  // 3. variable declaration and assignment using currentOpacity identifier
  var currentOpacity = window.getComputedStyle(imageToToggle).opacity;

  // 4. &#39;if&#39; portion of an if/else conditional statement
  if(currentOpacity == 1) {

    // 5. nested property assignment using imageToToggle reference
    imageToToggle.style.opacity = .5;

  // 6. end of &#39;if&#39;
  }

  // 7. &#39;else&#39; portion of an if/else conditional statement
  else {

    // 8. nested property assignment using imageToToggle reference
    imageToToggle.style.opacity = 1;

  // 9. end of &#39;else&#39; 
  }

// 10. end of toggleImageOpacity function
}
</code></pre><p>Now that the numbered comments provide a bit more context to each associated line of code, let&#39;s take a step deeper into each snippet. I do not expect you to understand everything we cover in the rest of this section however. Do not be discouraged if some words or ideas make no sense yet as this is expected. The intention of this section is to plant seeds in your mind regarding the vocabulary, concepts, and considerations of advanced coders. Extract what you can.</p>
<p>In snippet one there are four parts comprising the line of code:</p>
<pre><code>// 1. function declaration using toggleImageOpacity identifier
function toggleImageOpacity() {
</code></pre><ol>
<li><code>function</code> - keyword reserved by JavaScript denoting a function</li>
<li><code>toggleImageOpacity</code> - custom identifier for referencing the function by name</li>
<li><code>()</code> - <em>function signature input</em> defining how to call the function to do work</li>
<li><code>{</code> - opening curly brace for declaring the beginning of the <em>function body</em><ul>
<li><code>}</code> - a closing curly brace is expected after the <em>function body</em> for declaring its end</li>
<li>the <code>{</code> and <code>}</code> define the scope boundary of a function</li>
</ul>
</li>
</ol>
<p>The above four parts make up the anatomy of a function. First, the <code>function</code> keyword tells the JavaScript engine your intent to define a function. Second, a custom identifier is set to enable other code to properly reference and call the function by name. Third, the function&#39;s signature input defines what arguments the function expects to use when doing its work. No arguments are expected for <code>toggleImageOpacity</code> currently. Lastly, the <code>{</code> and <code>}</code> define the bounds of the function body. All functions return a value prior to closing the function body too, but this <em>function signature output</em> will be covered in the next chapter. </p>
<p>With respect to making snippet one <em>right</em> there is nothing we can do. A case could be made for making it <em>better</em> by renaming <code>toggleImageOpacity</code> to a single character alternative. This change is better for computers because there is less information to read which also translates to a smaller payload to send over a network. We won&#39;t make this change as we want to keep the code better for us humans. Research the <em>minification</em> process to learn about attaining the best of both worlds.</p>
<p>In snippet two there are five parts comprising the line of code:</p>
<pre><code>// 2. variable declaration and assignment using imageToToggle identifier
var imageToToggle = document.getElementById(&#39;image-to-toggle&#39;);
</code></pre><ol>
<li><code>var</code> - keyword reserved by JavaScript denoting a variable</li>
<li><code>imageToToggle</code> - custom identifier for referencing a value by name</li>
<li><code>=</code> - <em>assignment operator</em> that assigns the value on its right to the identifer on its left</li>
<li><code>document.getElementById(&#39;image-to-toggle&#39;)</code> - browser API for referencing a specific HTML element&#39;s object</li>
<li><code>;</code> - character reserved by JavaScript denoting the explicit end of a code statement</li>
</ol>
<p>The above five parts make up the anatomy of a declaration and assignment statement. The parts work together to assign the resulting value from the <code>document.getElementById()</code> browser API call to the declared <code>imageToToggle</code> identifier. In subsequent code, the identifier can be used as a shortcut to reference the actual element object and then use its API. It is worth noting that every use of <code>imageToToggle</code> could be replaced with <code>document.getElementById(&#39;image-to-toggle&#39;)</code>. This approach would <em>work</em>, but it would be <em>less right</em> because we&#39;d be doing the same work more times than needed.</p>
<p>Assigning an executed function&#39;s result to a variable identifier is an example of <em>caching</em>. Caching is a great approach for decreasing code volume and increasing execution time performance. The more expensive and time consuming the function call (blocking stack work), the more valuable caching is. Preventing repetitive work is the win with caching.</p>
<p>With respect to making snippet two <em>more right</em>, there is one other thing we could do. We could cache the <code>imageToToggle</code> lookup and assignment <em>outside</em> of the <code>toggleImageOpacity</code> function. In doing so, we would prevent the repetitive work that occurs each time <code>toggleImageOpacity</code> executes. This approach would require the identifier to never be reassigned to continue to work.</p>
<p>Additionally, an even <em>more right</em> approach could be made if <code>imageToToggle</code>&#39;s value would be useful to other code within our program. If this was the case then the variable wouldn&#39;t exist in the scope just outside the <code>toggleImageOpacity</code>&#39;s scope, but could instead exist in a higher level scope via the singleton design pattern. We mentioned this approach in the <em>Principles and Patterns</em> section, but the details are outside the scope of this book. Again, we&#39;re just planting seeds here so do not concern yourself with the details. We&#39;ll leave the snippet as is for simplicity and because there isn&#39;t anything <em>better</em> we can do.</p>
<p>In snippet three there are five parts comprising the line of code:</p>
<pre><code>  // 3. variable declaration and assignment using currentOpacity identifier
  var currentOpacity = window.getComputedStyle(imageToToggle).opacity;
</code></pre><p>Each part reflects the same general description as snippet two with the exception of <code>window.getComputedStyle(imageToToggle).opacity</code>. This part accesses the nested and specific <code>opacity</code> style object property of the cached <code>imageToToggle</code> element. The <code>opacity</code> property doesn&#39;t exist on the <code>imageToToggle</code> object itself and that is why we need the help of the API.</p>
<p>The previous snippet&#39;s suggestion to cache the identifier outside the <code>toggleImageOpacity</code> function is problematic in this snippet though. The difference is that <code>currentOpacity</code> is something we want to lookup <em>each time</em> the function executes. This is a requirement if we want an up-to-date opacity value. A change like this would result in a <em>less right</em> and ultimately broken set of code. Caching the style object returned from the <code>getComputedStyle(imageToToggle)</code> call outside the function scope could be considered <em>more right</em> however. Nothing <em>better</em> is possible.</p>
<p>In snippet four there are seven parts comprising the line of code:</p>
<pre><code>// 4. &#39;if&#39; portion of an if/else conditional statement
if(currentOpacity == 1) {
</code></pre><ol>
<li><code>if</code> - keyword reserved by JavaScript denoting conditional code execution</li>
<li><code>(</code> - opening paren for declaring the <code>if</code> condition beginning</li>
<li><code>currentOpacity</code> - custom identifier for referencing a value by name</li>
<li><code>==</code> - <em>loose equality</em> that coercively compares values on each side and produces a <code>true</code> or <code>false</code> value</li>
<li><code>1</code> - a literal number value</li>
<li><code>)</code> - closing paren for declaring the <code>if</code> condition end</li>
<li><code>{</code> - opening curly brace for declaring the beginning of the <code>if</code>-condition code block</li>
</ol>
<p>The above seven parts make up the anatomy of an <code>if</code> statement. First, the <code>if</code> keyword tells the JavaScript engine your intent to define a condition to control execution flow. When the condition is <code>true</code>, the code between its <code>{</code> and <code>}</code> will execute. If the condition is <code>false</code>, then the code block is skipped. The beginning <code>(</code> and ending <code>)</code> parens define the space where the condition in question resides. This condition is the comparison between the value in the <code>currentOpacity</code> identifier and the number value <code>1</code>. We will cover this again later, but <code>=</code> is used to <em>assign</em> where <code>==</code> is used to <em>compare</em>.</p>
<p>With respect to making snippet four <em>right</em> and <em>better</em>, we enter subjective changes. This subjectivity sources from a deeper understanding of JavaScript:</p>
<ol>
<li>Implicit coercion</li>
<li>Optional braces</li>
</ol>
<p>Implicit coercion is a nuanced sub-system of JavaScript. Coercion is a fancy word for interpreting a value in one form as another form. We&#39;ll leave the details to the next chapter, but just know that loose equality <code>==</code> allows coercion where <em>strict equality</em> <code>===</code> does not. Put another way, loose equality allows interpretation where strict equality does not.</p>
<p>Optional braces are an authoring time convenience for more succinct code writing. The snippet will remain as-is for now as many sub-systems and their caveats do not need to be learned to make code <em>work</em>.</p>
<p>In snippet five there are four parts comprising the line of code:</p>
<pre><code>// 5. nested property assignment using imageToToggle reference
imageToToggle.style.opacity = .5;
</code></pre><ol>
<li><code>imageToToggle.style.opacity</code> - nested identifier</li>
<li><code>=</code> - assignment operator that assigns the value on its right to the identifer on its left</li>
<li><code>.5</code> - a literal number value</li>
<li><code>;</code> - character reserved by JavaScript denoting the explicit end of a code statement</li>
</ol>
<p>The above four parts make up the anatomy of an assignment statement. This snippet has one small difference compared to snippet two. Where snippet two has a declaration and an assignment, this snippet only has the latter. The assumption made is that the nested identifiers <code>style</code> and <code>opacity</code> already exist. As a result, a simple assignment using <code>=</code> can be made.</p>
<p>Regarding <em>right</em> and <em>better</em>, we could cache the <code>imageToToggle.style</code> lookup. Technically speaking, each time the <code>imageToToggle.style.opacity</code> portion executes there is repetitive lookup work the engine has to do. We will not make this change as the performance benefit is negligible. This will be learned in time, but changes to increase performance should only be considered when the target framerate or user experience suffers. Put another way, &quot;premature optimization is the root of all evil&quot;. This exact quote is from Donald Knuth, a heavilty respected and influential coder. We will take his advice.</p>
<p>In snippet six there is only one part comprising the line of code:</p>
<pre><code>// 6. end of &#39;if&#39;
}
</code></pre><ol>
<li><code>}</code> - closing curly brace for declaring the end of the <code>if</code>-condition code block</li>
</ol>
<p>This closing curly brace simply defines the end of the <code>if</code> statement&#39;s code block. Nothing <em>right</em> or <em>better</em> is possible.</p>
<p>In snippet seven there are two parts comprising the line of code:</p>
<pre><code>// 7. &#39;else&#39; portion of an if/else conditional statement
else {
</code></pre><ol>
<li><code>else</code> - keyword reserved by JavaScript denoting conditional code execution</li>
<li><code>{</code> - opening curly brace for declaring the beginning of the <code>else</code>-condition code block</li>
</ol>
<p>The above two parts make up the anatomy of an <code>else</code> statement. The <code>else</code> is an optional execution flow that follows an <code>if</code> or <code>else if</code> statement. When the corresponding <code>if</code> or <code>else if</code> condition is <code>false</code>, the code between the <code>else</code>&#39;s <code>{</code> and <code>}</code> code block will execute. The <code>if</code>/<code>else</code> allows a program to branch, to have conditional execution flow at execution time. Specifically in our <code>toggleImageOpacity</code> function, we use this tactic to ping-pong, or toggle, an image&#39;s opacity between the values <code>1</code> and <code>.5</code>. Put another way, the program toggles the image&#39;s opacity between fully opaque (100%) and half transparent (50%). There is nothing <em>right</em> or <em>better</em> to do with this snippet.</p>
<p>In snippet eight there are four parts comprising the line of code:</p>
<pre><code>// 8. nested property assignment using imageToToggle reference
imageToToggle.style.opacity = 1;
</code></pre><ol>
<li><code>imageToToggle.style.opacity</code> - nested identifier</li>
<li><code>=</code> - assignment operator that assigns the value on its right to the identifer on its left</li>
<li><code>1</code> - a literal number value</li>
<li><code>;</code> - character reserved by JavaScript denoting the explicit end of a code statement</li>
</ol>
<p>Everything covered in snippet five can be said of this snippet. The only difference is the use of the literal value <code>1</code> in place of <code>.5</code>.</p>
<p>In snippet nine there is one part comprising the line of code:</p>
<pre><code>// 9. end of &#39;else&#39; 
}
</code></pre><ol>
<li><code>}</code> - closing curly brace for declaring the end of the <code>else</code>-condition code block</li>
</ol>
<p>This closing curly brace simply defines the end of the <code>else</code> statement&#39;s code block. There are no <em>right</em> or <em>better</em> improvements that are possible with this particular snippet. There is a <em>better</em> change possible when considering the entire <code>if</code>/<code>else</code> as a whole however. Snippets four through nine can be encapsulated more succintly using the <em>ternary operator</em>. The ternary operator does the same work as an <code>if</code>/<code>else</code>, but does so more succinctly (often in a single line of code):</p>
<pre><code>// Ternary operator alternative to an if/else that encapsulates snippets four through nine
imageToToggle.style.opacity = currentOpacity == 1 ? .5 : 1;
</code></pre><p>This is admittedly an advanced code statement, but it is functionally identical to the <code>if</code>/<code>else</code>. We won&#39;t go into its anatomy, but you could probably guess how it works. It is better for advanced JavaScript coders and less so for beginner coders. Subjectivity is at play.</p>
<p>In snippet ten there is one part comprising the line of code:</p>
<pre><code>// 10. end of toggleImageOpacity function
}
</code></pre><ol>
<li><code>}</code> - closing curly brace for declaring the end of the <em>function body</em><ul>
<li><code>{</code> - an opening curly brace is expected before the <em>function body</em> for declaring its beginning</li>
<li>the <code>{</code> and <code>}</code> define the scope boundary of a function</li>
</ul>
</li>
</ol>
<p>This closing curly brace simply defines the end of the <code>toggleImageOpacity</code> function. There are no <em>right</em> or <em>better</em> improvement possibilities.</p>
<p>In this section we introduced some of the vocabulary, concepts, and considerations of advanced coders. Overwhelming I know. Hopefully a few things made sense though. Regardless, seeds should be planted that will bear fruit later in your learn-to-code journey.</p>
<p>In the next chapter <em>Coding and JavaScript</em> we will bypass much of this advanced material in favor of a simplified approach. As you progress as a coder you can begin to make code <em>right</em> and <em>better</em>. Until then, the goal is to make code that works. Let&#39;s do this.</p>

  </section>

  <footer>
    <p>...</p>
  </footer>
</body>
</html>
